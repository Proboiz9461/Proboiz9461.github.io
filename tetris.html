<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Tetris</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body {
  margin: 0;
  background: black;
  display: flex;
  justify-content: center;
  align-items: center;
}
canvas {
  background: #111;
}
</style>
</head>
<body>

<canvas id="tetris" width="240" height="400"></canvas>

<script>
const canvas = document.getElementById("tetris");
const ctx = canvas.getContext("2d");
ctx.scale(20,20);

const moveS = new Audio("sounds/move.mp3");
const rotateS = new Audio("sounds/rotate.mp3");
const dropS = new Audio("sounds/drop.mp3");

function arenaSweep() {
  outer: for (let y = arena.length - 1; y > 0; y--) {
    for (let x = 0; x < arena[y].length; x++) {
      if (arena[y][x] === 0) continue outer;
    }
    arena.splice(y,1);
    arena.unshift(new Array(12).fill(0));
    dropS.play().catch(()=>{});
  }
}

function collide(arena, player) {
  const m = player.matrix;
  const o = player.pos;
  for (let y = 0; y < m.length; y++) {
    for (let x = 0; x < m[y].length; x++) {
      if (m[y][x] !== 0 &&
         (arena[y + o.y] &&
          arena[y + o.y][x + o.x]) !== 0) {
        return true;
      }
    }
  }
  return false;
}

function createMatrix(w,h){
  return Array.from({length:h},()=>new Array(w).fill(0));
}

function createPiece(type){
  if(type==='T') return [[0,1,0],[1,1,1],[0,0,0]];
  if(type==='O') return [[2,2],[2,2]];
  if(type==='L') return [[0,3,0],[0,3,0],[0,3,3]];
  if(type==='J') return [[0,4,0],[0,4,0],[4,4,0]];
  if(type==='I') return [[0,5,0,0],[0,5,0,0],[0,5,0,0],[0,5,0,0]];
  if(type==='S') return [[0,6,6],[6,6,0],[0,0,0]];
  if(type==='Z') return [[7,7,0],[0,7,7],[0,0,0]];
}

function drawMatrix(matrix,offset){
  matrix.forEach((row,y)=>{
    row.forEach((value,x)=>{
      if(value!==0){
        ctx.fillStyle="hsl("+value*40+",80%,60%)";
        ctx.fillRect(x+offset.x,y+offset.y,1,1);
      }
    });
  });
}

function draw(){
  ctx.fillStyle="#000";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  drawMatrix(arena,{x:0,y:0});
  drawMatrix(player.matrix,player.pos);
}

function merge(arena,player){
  player.matrix.forEach((row,y)=>{
    row.forEach((value,x)=>{
      if(value!==0){
        arena[y+player.pos.y][x+player.pos.x]=value;
      }
    });
  });
}

function rotate(matrix){
  matrix.forEach((row,i)=>{
    for(let j=0;j<i;j++){
      [row[j],matrix[j][i]]=[matrix[j][i],row[j]];
    }
  });
  matrix.forEach(row=>row.reverse());
}

function playerDrop(){
  player.pos.y++;
  if(collide(arena,player)){
    player.pos.y--;
    merge(arena,player);
    resetPlayer();
    arenaSweep();
  }
}

function playerMove(dir){
  player.pos.x+=dir;
  if(collide(arena,player)){
    player.pos.x-=dir;
  } else {
    moveS.play().catch(()=>{});
  }
}

function playerRotate(){
  rotate(player.matrix);
  if(collide(arena,player)) rotate(player.matrix);
  else rotateS.play().catch(()=>{});
}

function resetPlayer(){
  const pieces="TJLOSZI";
  player.matrix=createPiece(pieces[Math.random()*pieces.length|0]);
  player.pos.y=0;
  player.pos.x=(arena[0].length/2|0)-(player.matrix[0].length/2|0);
  if(collide(arena,player)) arena.forEach(row=>row.fill(0));
}

const arena=createMatrix(12,20);
const player={pos:{x:0,y:0},matrix:null};
resetPlayer();

document.addEventListener("keydown",e=>{
  if(e.key==="ArrowLeft") playerMove(-1);
  if(e.key==="ArrowRight") playerMove(1);
  if(e.key==="ArrowDown") playerDrop();
  if(e.key==="ArrowUp") playerRotate();
});

let dropCounter=0, dropInterval=500, lastTime=0;
function update(time=0){
  const delta=time-lastTime;
  lastTime=time;
  dropCounter+=delta;
  if(dropCounter>dropInterval){
    playerDrop();
    dropCounter=0;
  }
  draw();
  requestAnimationFrame(update);
}
update();
</script>
</body>
</html>
